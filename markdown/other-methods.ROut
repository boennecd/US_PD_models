
R version 3.5.3 (2019-03-11) -- "Great Truth"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #####
> # set directory
> local({
+   wd <- getwd()
+   if(!grepl("US_PD_models$", wd)){
+     cat("Changing directory...\n")
+     reg_e <- "(.+)(US_PD_models)(.+)"
+     stopifnot(grepl(reg_e, wd))
+     setwd(gsub(reg_e, "\\1\\2", wd))
+   }
+ })
> 
> #####
> # setup plot device and assign function to save output (after asking)
> pdf(file.path("markdown", "fig", "other-methods-%03d.pdf"), onefile = FALSE)
> library(tcltk)
> saveRDS_ask <- function(object, file){
+   save <- !file.exists(file) || 
+     tclvalue(tkmessageBox(
+       title = "Save?", message = "Want to save", type = "yesno")) == "yes"
+   
+   if(save){
+     cat("Saving...\n")
+     saveRDS(object, file)
+     return(invisible())
+     
+   }
+   
+   cat("Not saving...\n")
+ }
> 
> ##### 
> # source script to setup data
> source(knitr::purl(file.path("markdown", "setup.Rmd"), output = tempfile()))


processing file: markdown/setup.Rmd
  |                                                                         |                                                                 |   0%  |                                                                         |.....                                                            |   8%  |                                                                         |..........                                                       |  15%  |                                                                         |...............                                                  |  23%  |                                                                         |....................                                             |  31%  |                                                                         |.........................                                        |  38%  |                                                                         |..............................                                   |  46%  |                                                                         |...................................                              |  54%  |                                                                         |........................................                         |  62%  |                                                                         |.............................................                    |  69%  |                                                                         |..................................................               |  77%  |                                                                         |.......................................................          |  85%  |                                                                         |............................................................     |  92%  |                                                                         |.................................................................| 100%
output file: /tmp/RtmpR8Mg4F/fileded78fdd941


> wz <- function(x, probs = c(0.01, 0.99), lb = NULL, 
+     ub = NULL, do_scale = FALSE, scale = NULL, do_center = FALSE, 
+     mu = NULL) {
+     if (is.null(lb)) 
+         lb <- unname(quantile(x, probs[1]))
+     if (is.null(ub)) 
+         ub <- unname(quantile(x, probs[2]))
+     x <- pmin(pmax(x, lb), ub)
+     if (is.null(scale)) 
+         scale <- sd(x)
+     if (is.null(mu)) 
+         mu <- mean(x)
+     if (do_center) 
+         x <- x - mu
+     if (do_scale) 
+         x <- x/scale
+     structure(x, lb = lb, ub = ub, class = "wz", scale = scale, 
+         do_scale = do_scale, do_center = do_center, mu = mu)
+ }

> makepredictcall.wz <- function(var, call) {
+     if (as.character(call)[1] != "wz") 
+         return(call)
+     at <- attributes(var)[c("lb", "ub", "scale", "do_scale", 
+         "do_center", "mu")]
+     xxx <- call[1:2]
+     xxx[names(at)] <- at
+     xxx
+ }

> local({
+     set.seed(48350025)
+     df <- data.frame(y = rnorm(100), x = rnorm(100, 1, sd = 2))
+     f <- lm(y ~ wz(x), df)
+     mm <- model.matrix(f)
+     stopifnot(min(mm[, 2]) == quantile(df$x, 0.01), max(mm[, 
+         2]) == quantile(df$x, 0.99))
+     stopifnot(predict(f, newdata = df)[1:10] == predict(f, newdata = df[1:10, 
+         ]))
+     f <- lm(y ~ wz(x, do_scale = TRUE), df)
+     mm <- model.matrix(f)
+     stopifnot(isTRUE(all.equal(sd(mm[, 2]), 1)), predict(f, newdata = df)[1:10] == 
+         predict(f, newdata = df[1:10, ]))
+     f <- lm(y ~ wz(x, do_scale = TRUE, do_center = TRUE), df)
+     mm <- model.matrix(f)
+     stopifnot(isTRUE(all.equal(sd(mm[, 2]), 1)), isTRUE(all.equal(mean(mm[, 
+         2]), 0)), predict(f, newdata = df)[1:10] == predict(f, 
+         newdata = df[1:10, ]))
+ })

> sp_w_c <- function(x, df = NULL, lb = NULL, ub = NULL, 
+     probs = c(0.01, 0.99), Boundary.knots = NULL, knots = NULL, 
+     Z = NULL, do_excl_slope = TRUE, do_center = FALSE, mu = NULL) {
+     x <- wz(x, lb = lb, ub = ub, do_center = do_center, mu = mu, 
+         probs = probs, do_scale = FALSE)
+     lb <- attr(x, "lb")
+     ub <- attr(x, "ub")
+     do_center <- attr(x, "do_center")
+     mu <- attr(x, "mu")
+     if (is.null(knots) | is.null(Boundary.knots)) {
+         qs <- switch(df - 1, `4` = 0.5, `5` = c(0.1, 0.9), `6` = c(0.1, 
+             0.5, 0.9), `7` = c(0.05, 0.35, 0.65, 0.95), `8` = c(0.05, 
+             0.275, 0.5, 0.725, 0.95), `9` = c(0.05, 0.23, 0.41, 
+             0.59, 0.77, 0.95), `10` = c(0.025, 0.1833, 0.3417, 
+             0.5, 0.6583, 0.8167, 0.975), seq(0, 1, length.out = df + 
+             1)[-c(1, df + 1)])
+         if (length(qs) == 0 | (!qs[1] == 0 && !tail(qs, 1) == 
+             1)) 
+             qs <- c(0, qs, 1)
+         knots_use <- quantile(x, qs)
+         if (is.null(Boundary.knots)) 
+             Boundary.knots <- c(knots_use[1], knots_use[length(knots_use)])
+         if (is.null(knots)) 
+             knots <- knots_use[-c(1, length(knots_use))]
+     }
+     require(splines)
+     X <- ns(x, intercept = TRUE, knots = knots, Boundary.knots = Boundary.knots)
+     knots <- attr(X, "knots")
+     if (is.null(Z)) {
+         if (do_excl_slope) {
+             C <- crossprod(cbind(rep(1, nrow(X)), x), X)
+             qrc <- qr(t(C))
+             Z <- qr.Q(qrc, complete = TRUE)[, (nrow(C) + 1):ncol(C)]
+         }
+         else {
+             C <- rep(1, nrow(X)) %*% X
+             qrc <- qr(t(C))
+             Z <- qr.Q(qrc, complete = TRUE)[, (nrow(C) + 1):ncol(C)]
+         }
+     }
+     structure(X %*% Z, lb = lb, ub = ub, knots = knots, Boundary.knots = Boundary.knots, 
+         do_excl_slope = do_excl_slope, do_center = do_center, 
+         mu = mu, Z = Z, class = "sp_w_c")
+ }

> makepredictcall.sp_w_c <- function(var, call) {
+     if (as.character(call)[1] != "sp_w_c") 
+         return(call)
+     at <- attributes(var)[c("lb", "ub", "knots", "Boundary.knots", 
+         "Z", "do_excl_slope", "do_center", "mu")]
+     xxx <- call[1:2]
+     xxx[names(at)] <- at
+     xxx
+ }

> local({
+     set.seed(48350025)
+     df <- data.frame(y = rnorm(100), x = rnorm(100, 1, sd = 2))
+     f <- lm(y ~ wz(x, do_center = FALSE) + sp_w_c(x, 4), df)
+     mm <- model.matrix(f)
+     stopifnot(ncol(mm) == 5, sum(attr(mm, "assign") == 2) == 
+         3, predict(f, newdata = df)[1:10] == predict(f, newdata = df[1:10, 
+         ]))
+     tt <- attr(f$terms, "predvars")[[4]]
+     f2 <- lm(y ~ ns(wz(x, do_center = FALSE), knots = tt$knots, 
+         Boundary.knots = tt$Boundary.knots), df)
+     stopifnot(isTRUE(all.equal(predict(f), predict(f2))))
+     f3 <- lm(y ~ sp_w_c(x, 4, do_excl_slope = FALSE), df)
+     stopifnot(isTRUE(all.equal(predict(f), predict(f3))), sum(attr(model.matrix(f3), 
+         "assign") == 1) == 4)
+     f4 <- lm(y ~ wz(x) + sp_w_c(x, 4, do_center = TRUE), df)
+     stopifnot(isTRUE(all.equal(predict(f), predict(f4))))
+ })
Loading required package: splines

> plot_sp_w_c <- function(fit, term, ylab = "Linear predictor term") {
+     tt <- terms(fit)
+     w_tr <- which(grepl(paste0("^sp_w_c\\(", term), attr(tt, 
+         "term.labels")))
+     stopifnot(length(w_tr) == 1)
+     m_tr <- which(grepl(paste0("^wz\\(", term), attr(tt, "term.labels")) & 
+         attr(tt, "order") == 1)
+     stopifnot(length(m_tr) <= 1)
+     x <- eval(parse(text = term), fit$data)
+     df <- list()
+     df[[term]] <- seq(quantile(x, 0.01), quantile(x, 0.99), length.out = 1000)
+     k <- c(m_tr, w_tr)
+     tt <- terms(fit)
+     n_terms <- length(attr(tt, "term.labels"))
+     tt <- drop.terms(tt, setdiff(1:n_terms, k))
+     attr(tt, "intercept") <- 0
+     M <- model.matrix(tt, df)
+     cl <- colnames(M)
+     co <- coef(fit)[cl]
+     cv <- vcov(fit)[cl, cl]
+     se <- sqrt(diag(M %*% tcrossprod(cv, M)))
+     y <- drop(M %*% co)
+     lb <- y - 1.96 * se
+     ub <- y + 1.96 * se
+     function() {
+         plot(y ~ df[[1]], type = "l", xlab = get_label(term), 
+             ylab = ylab, ylim = range(lb, ub))
+         lines(df[[1]], lb, lty = 2)
+         lines(df[[1]], ub, lty = 2)
+         add_hist(wz(x, do_center = FALSE), breaks = 50)
+     }
+ }

> palette(c("#000000", "#E69F00", "#56B4E9", "#009E73", 
+     "#F0E442", "#0072B2", "#D55E00", "#CC79A7"))

> get_plot_device <- function(expr, file_name_wo_extension, 
+     onefile = TRUE, set_par = TRUE) {
+     if (!onefile) 
+         file_name_wo_extension <- paste0(file_name_wo_extension, 
+             "_%03d")
+     pdf. <- file.path("markdown", "fig", paste0(file_name_wo_extension, 
+         ".pdf"))
+     pdf_half <- file.path("markdown", "fig", paste0(file_name_wo_extension, 
+         "-half.pdf"))
+     jpeg. <- file.path("markdown", "fig", paste0(file_name_wo_extension, 
+         ".jpg"))
+     if (set_par) {
+         par_old <- par(no.readonly = TRUE)
+         on.exit(par(par_old))
+         expr <- bquote({
+             par(mar = c(5, 4, 1, 1))
+             .(substitute(expr))
+         })
+     }
+     else expr <- substitute(expr)
+     eval(expr, parent.frame())
+     jpeg(file = jpeg., width = 1900, height = 1200, res = 300)
+     on.exit(dev.off())
+     eval(expr, parent.frame())
+     dev.off()
+     pdf(file = pdf., width = 6, height = 3.75, onefile = onefile)
+     eval(expr, parent.frame())
+     dev.off()
+     pdf(file = pdf_half, width = 4, height = 3.75, onefile = onefile)
+     eval(expr, parent.frame())
+     invisible()
+ }

> get_label <- function(x) {
+     x <- as.character(x)
+     if (grepl(":", x)) {
+         z <- strsplit(x, ":")
+         return(paste0(sapply(z[[1]], get_label), collapse = " * "))
+     }
+     if (grepl("\\*", x)) {
+         z <- strsplit(x, "\\*")
+         return(paste0(sapply(z[[1]], get_label), collapse = " * "))
+     }
+     stopifnot(length(x) == 1)
+     switch(x, r_wcapq_atq = "Working capital / total assets", 
+         r_req_atq = "Retained Earnings / total assets", r_oiadpq_atq = "Operating income / total assets", 
+         r_saleq_atq = "Sales / total assets", r_niq_atq = "Net income / total assets", 
+         r_ltq_atq = "Total liabilities / total assets", r_mv_ltq = "Market value / total liabilities", 
+         r_mv_ltq_log = "log Market value / total liabilities", 
+         r_mv_atq = "Market value / total assets", r_wcapq_nn = "Working capital / size", 
+         r_req_nn = "Retained Earnings / size", r_oiadpq_nn = "Operating income / size", 
+         r_saleq_nn = "Sales / size", r_niq_nn = "Net income / size", 
+         r_ltq_nn = "Total liabilities / size", r_actq_lctq = "Current ratio", 
+         dtd = "Distance-to-default", sigma = "Idiosyncratic volatility", 
+         excess_ret = "Log excess return", log_market_ret = "Log market return", 
+         r1y = "T-bill rate", rel_size = "Relative log market size", 
+         actq_defl_log = "log current assets", atq_defl_log = "log total assets", 
+         stop("Not implemented for ", sQuote(x)))
+ }

> residuals. <- function(object, type = "pearson", ...) {
+     if (type != "martingale") {
+         cl <- match.call()
+         cl[[1]] <- quote(stats::residuals)
+         return(eval(cl, parent.frame()))
+     }
+     stopifnot(inherits(object, "glm"), object$family$family == 
+         "poisson", object$family$link == "log", all(object$y %in% 
+         0:1))
+     offs <- object$offset
+     etas <- object$linear.predictors - offs
+     ys <- object$y
+     ys - exp(etas + offs)
+ }

> add_hist <- function(x, breaks = 100) {
+     h <- hist(x, plot = FALSE, breaks = breaks)
+     nB <- length(h$breaks)
+     y <- h$counts
+     y_min <- par("usr")[3]
+     y_max <- par("usr")[4]
+     y_max <- y_max - 0.04 * (y_max - y_min)
+     y <- (y - 0)/(max(y) - 0) * (y_max - y_min) + y_min
+     rect(h$breaks[-nB], y_min, h$breaks[-1], y, border = par("fg"), 
+         angle = 45, col = rgb(0, 0, 0, 0.1))
+ }

> pear_vs_res <- function(fit, bw = 2, ylim = c(-0.05, 
+     0.05), type = "pearson") {
+     require(KernSmooth)
+     if (any(weights(fit) != 1)) 
+         warning("Some weights are not one. Plot may be missleading")
+     res <- residuals.(fit, type = type)
+     eta <- predict(fit, type = "link")
+     rg <- range(eta)
+     rg <- c(rg[1] - 1e-04 * diff(rg), rg[2] + 1e-04 * diff(rg))
+     ks <- locpoly(eta, res, bandwidth = bw, range.x = rg)
+     par_old <- par(no.readonly = TRUE)
+     on.exit(par(par_old))
+     par(mar = c(5, 4, 2, 2))
+     plot(ks, type = "l", xlab = expression(eta), ylab = type, 
+         ylim = ylim)
+     abline(h = 0, lty = 2)
+     add_hist(eta)
+ }

> resid_vs_covar <- function(fit, expr, bw = 1, ylim = NULL, 
+     keep = NULL, alter_par = TRUE, xlab_extra = NULL, silent = FALSE, 
+     type = "pearson") {
+     require(KernSmooth)
+     if (any(weights(fit) != 1)) 
+         warning("Some weights are not one. Plot may be missleading")
+     res <- residuals.(fit, type = type)
+     if (is.matrix(res) && type == "partial") {
+         sexpr <- deparse(substitute(expr))
+         if (!sexpr %in% colnames(res)) {
+             res <- with(fit, (y - family$linkinv(linear.predictors))/family$mu.eta(linear.predictors))
+             xvar <- eval(substitute(expr), fit$data)
+             xtrm <- rep(0, length(xvar))
+         }
+         else {
+             res <- res[, sexpr]
+             xvar <- model.matrix(terms(fit), fit$data)[, sexpr]
+             xtrm <- coef(fit)[sexpr] * xvar
+         }
+     }
+     qs <- quantile(res, c(0.001, 0.999))
+     resids <- pmin(pmax(res, qs[1]), qs[2])
+     if (!silent) {
+         cat("Residuals quantiles\n")
+         print(qs)
+     }
+     tr <- eval(substitute(expr), fit$data)
+     if (!is.null(keep)) {
+         res <- res[keep]
+         tr <- tr[keep]
+     }
+     if (missing(bw)) 
+         bw <- signif(0.2 * unname(diff(quantile(tr, c(0.05, 0.95)))), 
+             3)
+     rg <- range(tr)
+     rg <- c(rg[1] - 1e-04 * diff(rg), rg[2] + 1e-04 * diff(rg))
+     ks <- locpoly(tr, res, bandwidth = bw, range.x = rg)
+     if (is.null(ylim)) 
+         ylim <- if (type != "partial") 
+             range(ks$y)
+         else range(xtrm, ks$y)
+     if (alter_par) {
+         par_old <- par(no.readonly = TRUE)
+         on.exit(par(par_old))
+         par(mar = c(5, 4, 2, 2))
+     }
+     xlab <- paste0(deparse(substitute(expr)), collapse = " ")
+     if (!is.null(xlab_extra)) 
+         xlab <- paste(xlab, xlab_extra)
+     plot(ks, type = "l", xlab = xlab, ylab = type, ylim = ylim)
+     if (type != "partial") {
+         abline(h = 0, lty = 2)
+     }
+     else {
+         oid <- order(xvar)
+         lines(xvar[oid], xtrm[oid], lty = 2)
+     }
+     add_hist(tr)
+     legend("topright", bty = "n", legend = paste0("bw is ", bw), 
+         cex = par()$cex * 0.8)
+     rug(tr[fit$y == 1], col = "DarkBlue")
+ }

> resid_vs_covar_inter <- function(fit, by, expr, bw = 1, 
+     ylim = NULL, n_grp = 4, type = "pearson") {
+     cl <- match.call()
+     by_org <- substitute(by)
+     by <- eval(substitute(by), fit$data)
+     if (is.numeric(by)) {
+         brs <- seq(min(by), max(by), length.out = n_grp + 2)
+         brs <- cbind(brs[seq_len(n_grp)], brs[seq_len(n_grp) + 
+             2] + 1e-04)
+         grps <- matrix(NA, length(by), nrow(brs))
+         for (i in 1:nrow(brs)) grps[, i] <- brs[i, 1] <= by & 
+             by < brs[i, 2]
+         colnames(grps) <- paste0("[", sprintf("%.3f", brs[, 1]), 
+             ",", sprintf("%.3f", brs[, 2]), ")")
+     }
+     else if (is.factor(by) || is.logical(by)) {
+         grps <- model.matrix(~by - 1)
+         grps <- apply(grps, 2, `>`, y = 0)
+     }
+     else stop("not implemented")
+     cat("Groups are given below with number of observations for", 
+         sQuote(deparse(cl$by)), "\n")
+     print(colSums(grps))
+     cl[[1]] <- quote(resid_vs_covar)
+     cl <- cl[!names(cl) %in% c("n_grp", "by")]
+     cl$alter_par <- FALSE
+     cl$type <- type
+     par_old <- par(no.readonly = TRUE)
+     on.exit(par(par_old))
+     if (ncol(grps) <= 2) {
+         par(mfcol = c(1, 2))
+     }
+     else if (ncol(grps) <= 4) {
+         par(mfcol = c(2, 2))
+     }
+     else if (ncol(grps) <= 6) {
+         par(mfcol = c(2, 3))
+     }
+     else par(mfcol = c(3, 3))
+     par(mar = c(5.5, 4.5, 0, 0))
+     x <- eval(substitute(expr), fit$data)
+     if (missing(bw)) 
+         bw <- signif(0.2 * unname(diff(quantile(x, c(0.05, 0.95)))), 
+             3)
+     cl$bw <- bw
+     cl$silent = TRUE
+     for (i in 1:ncol(grps)) {
+         cl$keep <- quote(grps[, i])
+         cl$xlab_extra <- paste0("\n", deparse(match.call()$by), 
+             " ", colnames(grps)[i])
+         try(eval(cl))
+         if (inherits(try, "try-error")) 
+             plot.new()
+         else {
+             rug_keep <- which(grps[, i] & fit$y == 1)
+             rug(x[rug_keep], col = "DarkBlue")
+         }
+     }
+     if (is.factor(by) || is.logical(by)) 
+         return(invisible())
+     res <- residuals.(fit, type = type)
+     if (is.matrix(res) && type == "partial") {
+         res <- with(fit, (y - family$linkinv(linear.predictors))/family$mu.eta(linear.predictors))
+         trs <- predict(fit, type = "terms")
+         trs <- trs[, match(c(deparse(by_org), deparse(substitute(expr))), 
+             colnames(trs), 0), drop = FALSE]
+         res <- res + rowSums(trs)
+     }
+     qs <- quantile(res, c(0.001, 0.999))
+     resids <- pmin(pmax(res, qs[1]), qs[2])
+     v1 <- all.vars(substitute(expr))
+     v2 <- all.vars(by_org)
+     stopifnot(length(v1) == 1, length(v2) == 1)
+     assign(v1, eval(substitute(expr), fit$data))
+     assign(v2, eval(by_org, fit$data))
+     library(mgcv)
+     bam_fit <- eval(substitute(bam(resids ~ te(v1, v2, k = c(10, 
+         10), bs = "cr"), family = gaussian()), list(v1 = as.name(v1), 
+         v2 = as.name(v2))))
+     print(summary(bam_fit))
+     par(mar = c(5, 4, 0.5, 0.5), mfcol = c(2, 2))
+     for (x in 0:3) vis.gam(bam_fit, se = -1, theta = -35 + 90 * 
+         x, ticktype = "detailed")
+ }

> .nber_dates <- data.frame(start = as.Date(c("1980-01-01", 
+     "1981-07-01", "1990-07-01", "2001-03-01", "2007-12-01")), 
+     stop = as.Date(c("1980-07-29", "1982-11-29", "1991-03-29", 
+         "2001-11-29", "2009-06-29")))

> library(lubridate)

Attaching package: ‘lubridate’

The following object is masked from ‘package:base’:

    date


> .nber_dates <- within(.nber_dates, {
+     start_y <- year(start) + (month(start) - 1)/12 + (day(start) - 
+         1)/365
+     stop_y <- year(stop) + (month(stop) - 1)/12 + (day(stop) - 
+         1)/365
+ })

> nber_poly <- function(is_dates = FALSE, very_ligth_gray = FALSE) {
+     if (is_dates) {
+         ysa <- .nber_dates$start
+         yso <- .nber_dates$stop
+     }
+     else {
+         ysa <- .nber_dates$start_y
+         yso <- .nber_dates$stop_y
+     }
+     ylim <- par("usr")[3:4]
+     for (i in 1:nrow(.nber_dates)) rect(ysa[i], ylim[1], yso[i], 
+         ylim[2], col = rgb(0, 0, 0, if (very_ligth_gray) 
+             0.05
+         else 0.1), border = NA)
+     invisible(list(ylim, par("usr"), .nber_dates))
+ }
              r_wcapq_atq  r_req_atq r_oiadpq_atq   r_mv_ltq r_saleq_atq
r_req_atq                                                               
r_oiadpq_atq                                                            
r_mv_ltq                                                                
r_saleq_atq                                                             
r_niq_atq                               0.5606190                       
r_ltq_atq      -0.3392270 -0.4898712              -0.3559867            
r_actq_lctq     0.6910882                                               
sigma                     -0.3464922                                    
excess_ret                                                              
rel_size                   0.3006986                                    
atq_defl_log   -0.3146536                                               
actq_defl_log                                                           
dtd                                     0.3160158  0.4347130            
              r_niq_atq  r_ltq_atq r_actq_lctq      sigma excess_ret  rel_size
r_req_atq                                                                     
r_oiadpq_atq                                                                  
r_mv_ltq                                                                      
r_saleq_atq                                                                   
r_niq_atq                                                                     
r_ltq_atq                                                                     
r_actq_lctq                                                                   
sigma                                                                         
excess_ret                                     -0.3084316                     
rel_size                                       -0.5417277                     
atq_defl_log                                   -0.4264806            0.7205484
actq_defl_log                                  -0.3955511            0.7030133
dtd                     -0.3416162             -0.5462763  0.3546385 0.5774868
              atq_defl_log actq_defl_log dtd
r_req_atq                                   
r_oiadpq_atq                                
r_mv_ltq                                    
r_saleq_atq                                 
r_niq_atq                                   
r_ltq_atq                                   
r_actq_lctq                                 
sigma                                       
excess_ret                                  
rel_size                                    
atq_defl_log                                
actq_defl_log    0.9050427                  
dtd                                         


Winsorized
              r_wcapq_atq  r_req_atq r_oiadpq_atq   r_mv_ltq r_saleq_atq
r_req_atq                                                               
r_oiadpq_atq                                                            
r_mv_ltq                                                                
r_saleq_atq                                                             
r_niq_atq                               0.3479063                       
r_ltq_atq      -0.4644866 -0.6194708   -0.3206924 -0.4918388            
r_actq_lctq     0.5626341                                               
sigma                     -0.4947311   -0.4764670                       
excess_ret                                                              
rel_size                                                                
atq_defl_log   -0.4431076                                               
actq_defl_log                                                           
dtd                                                                     
               r_niq_atq r_ltq_atq r_actq_lctq      sigma excess_ret  rel_size
r_req_atq                                                                     
r_oiadpq_atq                                                                  
r_mv_ltq                                                                      
r_saleq_atq                                                                   
r_niq_atq                                                                     
r_ltq_atq     -0.3779695                                                      
r_actq_lctq                                                                   
sigma         -0.4291941 0.3592312                                            
excess_ret                                                                    
rel_size                                       -0.4072124                     
atq_defl_log                        -0.3551814                       0.4843768
actq_defl_log                                                        0.4668417
dtd                                            -0.4111696            0.3413152
              atq_defl_log actq_defl_log dtd
r_req_atq                                   
r_oiadpq_atq                                
r_mv_ltq                                    
r_saleq_atq                                 
r_niq_atq                                   
r_ltq_atq                                   
r_actq_lctq                                 
sigma                                       
excess_ret                                  
rel_size                                    
atq_defl_log                                
actq_defl_log    0.7552215                  
dtd                                         
                PC1   PC2   PC3   PC4   PC5   PC6   PC7   PC8   PC9  PC10  PC11
actq_defl_log -0.35 -0.23 -0.27  0.42 -0.13  0.09  0.08 -0.18  0.03 -0.05  0.30
atq_defl_log  -0.33 -0.38 -0.25  0.17 -0.09  0.10  0.09 -0.18  0.07 -0.10  0.22
rel_size      -0.42 -0.15 -0.14  0.03 -0.18  0.14 -0.17  0.15 -0.11  0.17 -0.79
excess_ret    -0.20  0.05  0.31 -0.18 -0.64 -0.50 -0.24 -0.32 -0.05 -0.05  0.08
sigma          0.36  0.09 -0.04  0.10 -0.06  0.43 -0.16 -0.76 -0.16  0.02 -0.19
r_actq_lctq    0.00  0.49 -0.30  0.12 -0.25 -0.04  0.32  0.06 -0.09  0.00 -0.02
r_ltq_atq      0.25 -0.31  0.29  0.26 -0.29  0.10  0.23  0.24 -0.57  0.38  0.12
r_niq_atq     -0.31  0.14  0.40 -0.08  0.09  0.15  0.42 -0.23  0.38  0.55  0.01
r_saleq_atq   -0.03  0.15  0.37  0.69  0.20 -0.09 -0.46  0.08  0.17  0.04 -0.01
r_mv_ltq      -0.24  0.30 -0.05 -0.25 -0.17  0.52 -0.47  0.23 -0.11  0.20  0.40
r_oiadpq_atq  -0.29  0.14  0.48  0.01  0.04  0.31  0.26  0.02 -0.26 -0.66 -0.06
r_req_atq     -0.33  0.13 -0.09 -0.08  0.53 -0.32 -0.06 -0.25 -0.60  0.19  0.08
r_wcapq_atq   -0.02  0.51 -0.19  0.35 -0.17 -0.10  0.17  0.05 -0.05  0.03 -0.06
               PC12  PC13
actq_defl_log -0.13 -0.63
atq_defl_log   0.16  0.71
rel_size       0.01 -0.04
excess_ret     0.01  0.00
sigma          0.01  0.01
r_actq_lctq    0.68 -0.06
r_ltq_atq      0.01  0.05
r_niq_atq      0.00  0.00
r_saleq_atq    0.25  0.09
r_mv_ltq      -0.03  0.04
r_oiadpq_atq  -0.02 -0.01
r_req_atq      0.03  0.02
r_wcapq_atq   -0.65  0.27
Loading required package: nlme
This is mgcv 1.8-24. For overview type 'help("mgcv-package")'.
                          mean       median standard deviation 1% quantile.1%
wz(dtd)          -6.751815e-07 -0.539633290         4.14423418    -7.46494918
wz(excess_ret)    1.523872e-07  0.037291696         0.39988336    -1.45883966
wz(r_wcapq_atq)   2.866911e-08 -0.023797368         0.16352372    -0.32071205
wz(r_oiadpq_atq)  6.776253e-18 -0.003069024         0.08787263    -0.30960825
wz(r_mv_ltq)     -3.649407e-07 -0.622175509         1.92708620    -1.64459810
wz(r_niq_atq)    -2.997445e-08  0.010203933         0.10287988    -0.55483834
wz(r_ltq_atq)    -3.946774e-17 -0.015501304         0.18886662    -0.39357044
wz(r_actq_lctq)  -5.066526e-17 -0.234565506         1.04172047    -1.41512634
wz(sigma)        -1.158918e-08 -0.003545951         0.01319539    -0.01595945
wz(rel_size)     -2.175699e-07  0.036880853         1.79224821    -4.49996095
                 99% quantile.99%
wz(dtd)               12.92172307
wz(excess_ret)         1.02125791
wz(r_wcapq_atq)        0.45355030
wz(r_oiadpq_atq)       0.27239444
wz(r_mv_ltq)          10.02861198
wz(r_niq_atq)          0.24578781
wz(r_ltq_atq)          0.72674842
wz(r_actq_lctq)        4.59565746
wz(sigma)              0.05492898
wz(rel_size)           4.09259425
\begin{tabular}{lrrrrr}
 \toprule & Mean & Median & Standard deviation & 1\% & 99\% \\
\midrule
Distance-to-default & -0.000 & -0.540 & 4.144 & -7.465 & 12.922 \\
Log excess return & 0.000 & 0.037 & 0.400 & -1.459 & 1.021 \\
Working capital / total assets & 0.000 & -0.024 & 0.164 & -0.321 & 0.454 \\
Operating income / total assets & 0.000 & -0.003 & 0.088 & -0.310 & 0.272 \\
Market value / total liabilities & -0.000 & -0.622 & 1.927 & -1.645 & 10.029 \\
Net income / total assets & -0.000 & 0.010 & 0.103 & -0.555 & 0.246 \\
Total liabilities / total assets & -0.000 & -0.016 & 0.189 & -0.394 & 0.727 \\
Current ratio & -0.000 & -0.235 & 1.042 & -1.415 & 4.596 \\
Idiosyncratic volatility & -0.000 & -0.004 & 0.013 & -0.016 & 0.055 \\
Relative log market size & -0.000 & 0.037 & 1.792 & -4.500 & 4.093 \\
\bottomrule
\end{tabular}> 
> #####
> # formulas that we use later
> f0 <- y ~ wz(r_wcapq_atq) + wz(r_oiadpq_atq) + wz(r_mv_ltq) + 
+   wz(r_niq_atq) + wz(r_ltq_atq) + wz(r_actq_lctq) + wz(sigma) + 
+   wz(excess_ret) + wz(rel_size) + wz(dtd) + log_market_ret + r1y + 
+   wz(actq_defl_log)
> 
> i0 <- update(
+   f0, . ~ . + sp_w_c(r_niq_atq, 3) + sp_w_c(sigma, 3) - wz(r_mv_ltq) + 
+     + wz(r_mv_ltq_log) + sp_w_c(r_mv_ltq_log, 3) + wz(r_actq_lctq):wz(sigma))
> 
> #####
> # glmnet
> library(glmnet)
Loading required package: Matrix
Loading required package: foreach
Loaded glmnet 2.0-16

> func <- function(frm, data, do_cv, lambda = NULL, family = "binomial", 
+                  foldid){
+   mf <- model.frame(frm, data)
+   X <- model.matrix(terms(mf), mf)
+   X <- X[, colnames(X) != "(Intercept)"]
+   y <- model.response(mf)
+   
+   cl <- quote(xyz(X, y, alpha = 0, family = family))
+   
+   if(do_cv){
+     library(parallel)
+     library(doParallel)
+     registerDoParallel(6L)
+     on.exit(stopImplicitCluster())
+     
+     
+     cl[c("type.measure", "parallel")] <- list("deviance", TRUE)
+     if(!missing(foldid))
+       cl[["foldid"]] <- quote(foldid)
+     cl[[1L]] <- quote(cv.glmnet)
+     return(eval(cl, environment()))
+   }
+   
+   cl[[1L]] <- quote(glmnet)
+   cl["lambda"] <- lambda
+   eval(cl, environment())
+ }
> 
> set.seed(24203767)
> g1 <- func(i0, dat, do_cv = TRUE)
Loading required package: iterators
> saveRDS_ask(g1, file.path("markdown", "cache", "glmnet-cv.RDS"))
Saving...
> plot(g1)
> 
> g2 <- func(i0, dat, do_cv = FALSE)
> dim(coef(g2))
[1]  21 100
> min(log(g2$lambda))
[1] -7.738191
> glm_fit <- glm(i0, binomial(), dat)
> cbind(coef(g2)[, 95:100], i0 = coef(glm_fit))
21 x 7 sparse Matrix of class "dgCMatrix"
                                   s94         s95          s96         s97
(Intercept)               -8.656342636 -8.70808414 -8.758652969 -8.80868057
wz(r_wcapq_atq)           -0.789894020 -0.81757180 -0.845204885 -0.87263117
wz(r_oiadpq_atq)          -1.428321448 -1.42345735 -1.418355320 -1.41224758
wz(r_niq_atq)             -1.992667789 -2.00701457 -2.020478358 -2.03182802
wz(r_ltq_atq)              0.729243420  0.72452734  0.719203197  0.71303808
wz(r_actq_lctq)           -0.119544776 -0.12681217 -0.134494162 -0.14263225
wz(sigma)                 25.858306468 26.43464120 27.029793838 27.65094106
wz(excess_ret)            -1.371171129 -1.39058875 -1.408943374 -1.42643015
wz(rel_size)              -0.159003993 -0.16273335 -0.166527107 -0.17050443
wz(dtd)                   -0.038106447 -0.03789120 -0.037583040 -0.03725140
log_market_ret             0.563839005  0.58591294  0.607133730  0.62743742
r1y                        2.197012663  2.31049351  2.424537703  2.53870845
wz(actq_defl_log)          0.006719621  0.01042422  0.014249533  0.01818494
sp_w_c(r_niq_atq, 3)1     -0.016173356 -0.02695470 -0.037120300 -0.04567937
sp_w_c(r_niq_atq, 3)2      0.909705002  0.91018404  0.909918159  0.90942943
sp_w_c(sigma, 3)1          0.554402408  0.53253401  0.508393967  0.48205848
sp_w_c(sigma, 3)2         -0.362040359 -0.38832557 -0.413060846 -0.43665385
wz(r_mv_ltq_log)          -0.253025913 -0.25859488 -0.264224171 -0.26987677
sp_w_c(r_mv_ltq_log, 3)1   0.927010045  0.92317690  0.917884433  0.91064032
sp_w_c(r_mv_ltq_log, 3)2   1.257091003  1.29652485  1.334753174  1.37130777
wz(r_actq_lctq):wz(sigma) -0.582095817 -0.29892597 -0.009948679  0.28536993
                                  s98         s99          i0
(Intercept)               -8.85661605 -8.90347716 -10.4687983
wz(r_wcapq_atq)           -0.89974281 -0.92644047  -0.9131541
wz(r_oiadpq_atq)          -1.40712374 -1.40157847  -1.2285371
wz(r_niq_atq)             -2.04396842 -2.05574659  -2.0940474
wz(r_ltq_atq)              0.70684611  0.70047531   0.4222752
wz(r_actq_lctq)           -0.15116253 -0.16021067  -0.8108875
wz(sigma)                 28.28833609 28.96777252 107.8851125
wz(excess_ret)            -1.44263808 -1.45796145  -1.7611272
wz(rel_size)              -0.17439033 -0.17837246  -0.2928278
wz(dtd)                   -0.03671798 -0.03604961   0.1535356
log_market_ret             0.64683806  0.66533657   0.9205240
r1y                        2.65285719  2.76666225   5.1529482
wz(actq_defl_log)          0.02222134  0.02638692   0.1576579
sp_w_c(r_niq_atq, 3)1     -0.05490312 -0.06395696  -0.1132406
sp_w_c(r_niq_atq, 3)2      0.90783364  0.90547895   0.7186179
sp_w_c(sigma, 3)1          0.45313166  0.42088999  -4.2813480
sp_w_c(sigma, 3)2         -0.45853830 -0.47953571  -1.5312466
wz(r_mv_ltq_log)          -0.27561561 -0.28130062  -0.8135284
sp_w_c(r_mv_ltq_log, 3)1   0.90238065  0.89246488  -1.9022975
sp_w_c(r_mv_ltq_log, 3)2   1.40659236  1.43969129   0.4222341
wz(r_actq_lctq):wz(sigma)  0.58517122  0.89265887  15.1130643
> 
> # cross-validation where we sample periods. Make breaks
> n_brs <- 11L
> brs <- dat$tstop
> brs <- seq.int(min(brs), max(brs), length.out = n_brs)
> brs <- as.integer(brs)
> brs[n_brs] <- max(dat$tstop)
> brs[1] <- brs[1] - 1L
> 
> # make dummies
> labs <- paste0(
+   "(", format(make_ym_inv(brs[-n_brs]), "%Y-%m"), ", " ,
+   format(make_ym_inv(brs[-1]), "%Y-%m"), "]")
> 
> dat$year_dummy <- cut(dat$tstop, breaks = brs, labels = labs)
> stopifnot(!anyNA(dat$year_dummy))
> table(dat$year_dummy, dat$y)
                    
                     FALSE  TRUE
  (1980-01, 1983-10] 22652    13
  (1983-10, 1987-06] 25653    40
  (1987-06, 1991-02] 29460    46
  (1991-02, 1994-10] 29423    51
  (1994-10, 1998-06] 38554    45
  (1998-06, 2002-02] 43197   146
  (2002-02, 2005-10] 42141    75
  (2005-10, 2009-06] 41345    44
  (2009-06, 2013-02] 38840    30
  (2013-02, 2016-10] 39625    65
> 
> # run cross-validation
> set.seed(24203767)
> g3 <- func(i0, dat, do_cv = TRUE, foldid = as.integer(dat$year_dummy))
> saveRDS_ask(g3, file.path("markdown", "cache", "glmnet-cv-years.RDS"))
Saving...
> plot(g3)
> 
> #####
> # boosted trees
> library(xgboost)
> X <- model.matrix(f0, dat)
> X <- X[, colnames(X) != "(Intercept)"]
> y <- model.response(model.frame(f0, dat))
> xg_dat <- xgb.DMatrix(data = X, label = y)
> 
> set.seed(24203767)
> depths <- 4:1
> names(depths) <- 4:1
> eta_use <- .02
> xgb_cv_out <- lapply(depths, function(depth){
+   cb_func <- function (period = 100L) {
+     callback <- function(env = parent.frame()) {
+       if (length(env$bst_evaluation) == 0 || period == 0)
+         return()
+       i <- env$iteration
+       if ((i - 1)%%period == 0 || i == env$begin_iteration || i == env$end_iteration)
+         cat(sprintf(
+           "depth: %1d it: %4d train: %7.5f test: %7.5f\n", 
+           depth, i, env$bst_evaluation[1], env$bst_evaluation[2]))
+     }
+     attr(callback, 'call') <- match.call()
+     attr(callback, 'name') <- 'cb-func'
+     callback
+   }
+   xgb.cv(
+     params = list(objective = "binary:logistic", max_depth = depth, 
+                   eta = eta_use, nthread = 6L), 
+     xg_dat, nfold = 5L, metrics = "logloss", nrounds = 5000L, verbose = F,
+     callbacks = list(cb_func()), early_stopping_rounds = 100L)
+ })
depth: 4 it:    1 train: 0.67379 test: 0.67344
depth: 4 it:  101 train: 0.07282 test: 0.07307
depth: 4 it:  201 train: 0.01493 test: 0.01542
depth: 4 it:  301 train: 0.00740 test: 0.00823
depth: 4 it:  401 train: 0.00623 test: 0.00733
depth: 4 it:  501 train: 0.00588 test: 0.00722
depth: 4 it:  601 train: 0.00560 test: 0.00721
depth: 3 it:    1 train: 0.67379 test: 0.67344
depth: 3 it:  101 train: 0.07298 test: 0.07309
depth: 3 it:  201 train: 0.01524 test: 0.01549
depth: 3 it:  301 train: 0.00787 test: 0.00829
depth: 3 it:  401 train: 0.00678 test: 0.00737
depth: 3 it:  501 train: 0.00649 test: 0.00722
depth: 3 it:  601 train: 0.00628 test: 0.00718
depth: 3 it:  701 train: 0.00610 test: 0.00717
depth: 2 it:    1 train: 0.67379 test: 0.67344
depth: 2 it:  101 train: 0.07311 test: 0.07316
depth: 2 it:  201 train: 0.01550 test: 0.01563
depth: 2 it:  301 train: 0.00821 test: 0.00843
depth: 2 it:  401 train: 0.00714 test: 0.00746
depth: 2 it:  501 train: 0.00691 test: 0.00730
depth: 2 it:  601 train: 0.00677 test: 0.00724
depth: 2 it:  701 train: 0.00665 test: 0.00720
depth: 2 it:  801 train: 0.00656 test: 0.00718
depth: 2 it:  901 train: 0.00648 test: 0.00717
depth: 2 it: 1001 train: 0.00641 test: 0.00716
depth: 2 it: 1101 train: 0.00634 test: 0.00716
depth: 1 it:    1 train: 0.67379 test: 0.67344
depth: 1 it:  101 train: 0.07329 test: 0.07332
depth: 1 it:  201 train: 0.01595 test: 0.01600
depth: 1 it:  301 train: 0.00866 test: 0.00874
depth: 1 it:  401 train: 0.00751 test: 0.00765
depth: 1 it:  501 train: 0.00722 test: 0.00742
depth: 1 it:  601 train: 0.00710 test: 0.00733
depth: 1 it:  701 train: 0.00703 test: 0.00729
depth: 1 it:  801 train: 0.00699 test: 0.00726
depth: 1 it:  901 train: 0.00695 test: 0.00724
depth: 1 it: 1001 train: 0.00692 test: 0.00723
depth: 1 it: 1101 train: 0.00689 test: 0.00722
depth: 1 it: 1201 train: 0.00687 test: 0.00721
depth: 1 it: 1301 train: 0.00685 test: 0.00720
depth: 1 it: 1401 train: 0.00683 test: 0.00720
depth: 1 it: 1501 train: 0.00682 test: 0.00720
depth: 1 it: 1601 train: 0.00681 test: 0.00719
depth: 1 it: 1701 train: 0.00679 test: 0.00719
depth: 1 it: 1801 train: 0.00678 test: 0.00719
depth: 1 it: 1901 train: 0.00677 test: 0.00719
> saveRDS_ask(xgb_cv_out, file.path("markdown", "cache", "xgb-cv.RDS"))
Saving...
> 
> logs <- lapply(xgb_cv_out, "[[", "evaluation_log")
> logs <- lapply(logs, "[[", "test_logloss_mean")
> # get deviance insetad
> logs <- lapply(logs, '*', 2)
> 
> # cut away the first indices
> start_at <- 300L
> max_length <- max(sapply(logs, length))
> stopifnot(all(max_length > start_at), start_at >= 2L)
> logs <- lapply(logs, function(x) x[-(1:(start_at - 1L))])
> 
> # plot
> par(mar = c(5, 4, .5, .5))
> plot(1, type = "n", xlim = c(start_at, max_length), ylim = 
+      range(logs), ylab = "deviance")
> for(i in 1:4)
+   lines(seq_along(logs[[i]]) - 1L + start_at, logs[[i]], lty = i)
> 
> legend("topright", legend = names(logs), lty = seq_along(logs), bty = "n")
> 
> # minimum and standard deviations
> sapply(logs, min)
        4         3         2         1 
0.0144072 0.0143428 0.0143220 0.0143812 
> sapply(logs, which.min) + start_at - 1L
   4    3    2    1 
 559  672 1084 1850 
> local({
+   lgs <- lapply(xgb_cv_out, function(x) x$evaluation_log)  
+   mins <- sapply(lgs, function(x) which.min(x$test_logloss_mean))
+   mapply(`[`, lapply(lgs, `[[`, "test_logloss_std"), mins)
+ })
           4            3            2            1 
0.0005549856 0.0004721265 0.0006878878 0.0005471740 
> 
> # boost stumps
> xgb_fit <- xgb.train(
+   params = list(objective = "binary:logistic", max_depth = 1L, 
+                 eta = eta_use, nthread = 6L),
+   data = xg_dat, nrounds = 1500L)
> (imp <- xgb.importance(model = xgb_fit))
              Feature        Gain       Cover  Frequency
 1:    wz(excess_ret) 0.404685998 0.876814208 0.19533333
 2:         wz(sigma) 0.159296718 0.032240914 0.11066667
 3:      wz(r_mv_ltq) 0.155000478 0.018951502 0.12466667
 4:     wz(r_niq_atq) 0.077731197 0.006616637 0.04733333
 5:           wz(dtd) 0.074572835 0.011187849 0.08000000
 6:      wz(rel_size) 0.059859652 0.014070228 0.06666667
 7:     wz(r_ltq_atq) 0.017964795 0.003783838 0.03400000
 8:   wz(r_actq_lctq) 0.012516234 0.006979360 0.06533333
 9: wz(actq_defl_log) 0.010490822 0.011232465 0.10600000
10:   wz(r_wcapq_atq) 0.008900520 0.002819567 0.02600000
11:    log_market_ret 0.008542870 0.006663150 0.06266667
12:  wz(r_oiadpq_atq) 0.006969639 0.004406370 0.04133333
13:               r1y 0.003468243 0.004233911 0.04000000
> 
> # look at partial effects
> local({
+   set.seed(32997487)
+   Xt <- X[sample.int(nrow(X), min(nrow(X), 10000L)), ]
+   plot_info <- lapply(colnames(X), function(s){
+     z <- X[, s]
+     z_grid <- seq(min(z), max(z), length.out = 201)
+     y_hat <- sapply(z_grid, function(x){
+       Xt[, s] <- x
+       y_hat <- predict(xgb_fit, newdata = Xt, outputmargin = TRUE)
+       mean(y_hat)
+     })
+     y_hat <- y_hat - mean(y_hat)
+     
+     list(y_hat = y_hat, z_grid = z_grid)
+   })
+   names(plot_info) <- colnames(X)
+ 
+   par(mar = c(5, 4, 1, 1), mfcol = c(2, 2))
+   y_lim <- range(lapply(plot_info, "[[", "y_hat"))
+   for(i in seq_along(plot_info))
+     plot(plot_info[[i]]$z_grid, plot_info[[i]]$y_hat, ylim = y_lim,
+          type = "l", xlab = names(plot_info)[i], ylab = "log-odds")
+ })
> 
> # boost deepth two tree
> xgb_fit_two <- xgb.train(
+   params = list(objective = "binary:logistic", max_depth = 2L, 
+                 eta = eta_use, nthread = 6L),
+   data = xg_dat, nrounds = 1000L)
> (imp <- xgb.importance(model = xgb_fit_two))
              Feature        Gain       Cover  Frequency
 1:    wz(excess_ret) 0.433063853 0.642460470 0.16800000
 2:           wz(dtd) 0.137663518 0.026102817 0.06966667
 3:         wz(sigma) 0.132743540 0.206458965 0.12333333
 4:      wz(r_mv_ltq) 0.104354040 0.011811348 0.11066667
 5:     wz(r_niq_atq) 0.046138983 0.006654411 0.08566667
 6:      wz(rel_size) 0.040892112 0.078627816 0.08500000
 7:     wz(r_ltq_atq) 0.023714550 0.005019229 0.06266667
 8:   wz(r_actq_lctq) 0.017701901 0.004058911 0.04766667
 9:  wz(r_oiadpq_atq) 0.017437428 0.003572120 0.05300000
10:               r1y 0.014879625 0.002824819 0.04700000
11:    log_market_ret 0.011680951 0.003539888 0.04233333
12: wz(actq_defl_log) 0.011344997 0.006740142 0.06566667
13:   wz(r_wcapq_atq) 0.008384503 0.002129063 0.03933333
> 
> library(data.table)

Attaching package: ‘data.table’

The following objects are masked from ‘package:lubridate’:

    hour, isoweek, mday, minute, month, quarter, second, wday, week,
    yday, year

> local({
+   tree_dat <- xgb.model.dt.tree(model = xgb_fit_two)  
+   tree_dat <- tree_dat[Feature != "Leaf"]
+   func <- function(.SD){
+     root <- .SD$Feature[1]
+     lvl_2 <- .SD[2:3, ]
+     lvls_2 <- lvl_2[, Feature := ifelse(
+       Feature < root, 
+       paste0(Feature, ":", root),
+       paste0(root, ":", Feature))]
+     rbind(.SD[1, ], lvls_2)
+   }
+   tree_dat <- tree_dat[, func(.SD), by = Tree]
+   tree_dat <- tree_dat[
+     , .(Quality = sum(Quality), Frequency = .N), by = Feature]
+   tree_dat[, `:=`(Quality = Quality / sum(Quality), 
+                   Frequency = Frequency / sum(Frequency))]
+   print(head(tree_dat[order(Quality, decreasing = TRUE)], 50))
+ })
                                Feature     Quality   Frequency
 1:                      wz(excess_ret) 0.412128478 0.108000000
 2:                             wz(dtd) 0.126710497 0.028333333
 3:                           wz(sigma) 0.102854856 0.050000000
 4:         wz(excess_ret):wz(r_mv_ltq) 0.060958695 0.051000000
 5:                        wz(r_mv_ltq) 0.034462482 0.034666667
 6:            wz(excess_ret):wz(sigma) 0.027614020 0.062000000
 7:               wz(dtd):wz(r_niq_atq) 0.023762015 0.026333333
 8:         wz(excess_ret):wz(rel_size) 0.020798348 0.034666667
 9:        wz(excess_ret):wz(r_ltq_atq) 0.012761943 0.015333333
10:      wz(excess_ret):wz(r_actq_lctq) 0.009682994 0.014333333
11:              wz(rel_size):wz(sigma) 0.009089286 0.018000000
12:              wz(r_mv_ltq):wz(sigma) 0.008412145 0.009333333
13:              wz(dtd):wz(excess_ret) 0.008133518 0.024666667
14:          wz(r_mv_ltq):wz(r_niq_atq) 0.007771133 0.024000000
15:                       r1y:wz(sigma) 0.006150924 0.018333333
16:        wz(excess_ret):wz(r_niq_atq) 0.005838569 0.008666667
17:           wz(r_actq_lctq):wz(sigma) 0.005479887 0.014333333
18:     wz(excess_ret):wz(r_oiadpq_atq) 0.005237797 0.012666667
19:                       wz(r_niq_atq) 0.005008511 0.011000000
20:                    r1y:wz(rel_size) 0.004640772 0.012666667
21:                        wz(rel_size) 0.004305501 0.014000000
22:                   wz(actq_defl_log) 0.004224452 0.037666667
23:            wz(dtd):wz(r_oiadpq_atq) 0.003914114 0.005666667
24:      wz(actq_defl_log):wz(r_mv_ltq) 0.003871650 0.010666667
25:       wz(r_ltq_atq):wz(r_wcapq_atq) 0.003560907 0.011666667
26:             wz(r_niq_atq):wz(sigma) 0.003455775 0.004000000
27:         log_market_ret:wz(r_mv_ltq) 0.003239240 0.010666667
28:                wz(dtd):wz(rel_size) 0.003059806 0.005333333
29:       wz(r_mv_ltq):wz(r_oiadpq_atq) 0.003011740 0.005666667
30:          wz(r_oiadpq_atq):wz(sigma) 0.002962794 0.011666667
31:               wz(dtd):wz(r_ltq_atq) 0.002568575 0.002333333
32:      wz(actq_defl_log):wz(rel_size) 0.002564314 0.010666667
33:             wz(dtd):wz(r_actq_lctq) 0.002513490 0.007666667
34:         wz(actq_defl_log):wz(sigma) 0.002498581 0.009000000
35:      wz(excess_ret):wz(r_wcapq_atq) 0.002431388 0.008666667
36:            log_market_ret:wz(sigma) 0.002399176 0.008333333
37:       wz(excess_ret):wz(excess_ret) 0.002382962 0.013333333
38:           wz(r_wcapq_atq):wz(sigma) 0.002351624 0.004666667
39:     wz(actq_defl_log):wz(r_niq_atq) 0.002250857 0.013000000
40:       log_market_ret:wz(excess_ret) 0.002228142 0.007000000
41: wz(actq_defl_log):wz(actq_defl_log) 0.002191185 0.011000000
42:    wz(actq_defl_log):wz(excess_ret) 0.001895376 0.008000000
43:       wz(r_oiadpq_atq):wz(rel_size) 0.001807952 0.009666667
44:         wz(r_niq_atq):wz(r_niq_atq) 0.001800575 0.005666667
45:             wz(dtd):wz(r_wcapq_atq) 0.001791422 0.005666667
46:    log_market_ret:wz(actq_defl_log) 0.001686617 0.007666667
47:                     wz(r_actq_lctq) 0.001654359 0.012666667
48:          wz(r_ltq_atq):wz(r_mv_ltq) 0.001611970 0.013000000
49:                         r1y:wz(dtd) 0.001610496 0.005333333
50:                     wz(r_wcapq_atq) 0.001538444 0.011666667
                                Feature     Quality   Frequency
> 
> # make sure to shut down the plot device
> dev.off()
null device 
          1 
> 
> proc.time()
     user    system   elapsed 
10688.232    15.549  1995.298 
